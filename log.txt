2015-05-13

TODO: Make sure the cardinality of "XRV" is no bigger than the cardinality of X.
  (to make the tabulation feasible)

From Finite X -> Dec (Reachable x) -> Dec (Viable n x) -> Finite (

See prototypes/PreTab.lidr


2015-05-13: Patrik + Nicola: status

TODO:
* create sub-modules for XOperations.lidr -> X/Operations, XProperties.lidr -> X/Properties.lidr
* separate library components from domain-specific components
** some library components are intended as extensions to Idris library components (Nat for example) - could later be merged into the Idris code base
* how to handle variants of the theory?
* add one (or more) package file(s)
* explore which modules should re-export which other definitions

* Library components
Basics.lidr -- For proofs

BoundedNat.lidr
BoundedNatOperations.lidr
BoundedNatProperties.lidr

ContainerMonad.lidr

Decidable.lidr
DecidableProperties.lidr

EffectException.lidr
EffectStdIO.lidr

EmbProj.lidr
EqualityProperties.lidr
FinOperations.lidr
FinProperties.lidr
Finite.lidr
FiniteOperations.lidr
FiniteProperties.lidr
FiniteSubType.lidr
FiniteSubTypeOperations.lidr
FiniteSubTypeProperties.lidr
FunOperations.lidr
FunProperties.lidr
IdentityOperations.lidr
IdentityProperties.lidr
IsomorphismOperations.lidr
IsomorphismProperties.lidr

LambdaPostulates.lidr
NatProperties.lidr

Order.lidr
OrderOperations.lidr
OrderProperties.lidr

Preorder.lidr
PreorderOperations.lidr
Prop.lidr
RelFloat.lidr
RelFloatPostulates.lidr
RelFloatProperties.lidr
RelSyntax.lidr

SigmaOperations.lidr
SigmaProperties.lidr
SingletonProperties.lidr
SoProperties.lidr
SubType.lidr
TotalPreorder.lidr
TotalPreorderOperations.lidr
Unique.lidr
UniqueProperties.lidr
Util.lidr
VectOperations.lidr
VectProperties.lidr

tagging.lidr   -- TODO: Check

* Intermediate library components
Opt.lidr


* Domain-specific components
SeqDecProbMonadicSmallTheory.lidr
SeqDecProbMonadicSmallTheoryExample2.lidr

SeqDecProbMonadic.lidr
SeqDecProbMonadicExample2.lidr
SeqDecProbMonadicTheory.lidr
SeqDecProbMonadicTheoryExample2.1.lidr
SeqDecProbMonadicTheoryExample2.lidr

* Issue reports
issue_reports

* Other
funprogintro.lidr
idris-lang


2015-04-29: Patrik: Current status

  One missing metavariable when loading SeqDecProbMonadicExample2.lidr:
    VectProperties.injectiveFilterLemma
  Call chain? (what part of the proof depends on this?):
    (Unclear - the lemma is never used.)

  New try:
    make run
    # (compiles ~/src/ext/SeqDecProbs/SeqDecProbMonadicTheoryExample2.lidr)
patrikj@etyd:~/src/ext/SeqDecProbs$ make
idris -p contrib -p effects SeqDecProbMonadicTheoryExample2.lidr -o example
There are undefined metavariables: [SeqDecProbMonadicTheory.tabOptExt,SeqDecProbMonadicTheory.fX,VectProperties.injectiveFilterLemma]
  Fixed those (by commenting them out).
  Now the example runs.
  (But the theory has at least one hole.)

2015-03-05: Patrik: Left to do

  Problems in SeqDecProbMonadicExample2.lidr:

  The current formalisation of max and argmax are parametrised on an
  arbitrary function (f : A -> B) into a preorder B.

  The actual use of this is to choose a "control" of type (Y t x) for
  which a certain function is maximal. The actual type of the function
  to be maximised is from a subset of (Y t x) implemented as a Sigma
  type (Sigma (Y t x) (\ y => All (Viable {t = S t} n) (step t x y))).
  The details are not important, but what is important is that the
  type is of the form (Sigma A P) where P is a predicate intended to
  "carve out" the subset of controls which lead to viable next states.

  The function being optimized takes a value (y ** av) where y is used
  to compute a value and av is used to compute "certificates" needed
  to be allowed to call some functions needed to compute the value.

  My hypothesis is that what we need to proceed is a proof that the
  second component does not change the value of this function. This
  should be possible to formulate as (TODO: better name;-)

  Nice : {A : Type} -> {P : A -> Prop} -> (f : Sigma A P -> float) -> Prop
  Nice f = (y : A) -> (av : P y) -> (av' : P y) -> (f (y ** av) = f (y ** av'))

  The proof may be awkward but I think something of this king is
  needed instead of the (too strong) requirement Unique1 P.

  The function used for the optimization (in SeqDecProbMonadic.lidr)
  is built using the helpers mkg, mkf and val.

2015-02-25: Patrik: checking status

  New files added:
    BoundedNatOperations.lidr      -- OK
    BoundedNatProperties.lidr      -- OK, but import metas from VectProperties and BoundedNat
    FiniteSubType.lidr             -- OK
    FiniteSubTypeOperations.lidr   -- OK
    FiniteSubTypeProperties.lidr   -- OK, but import metas from VectProperties
    Order.lidr                     -- OK
    OrderOperations.lidr           -- OK
    OrderProperties.lidr           -- OK
    RelFloatPostulates.lidr        -- Postulates
    RelFloatProperties.lidr        -- empty!
    RelSyntax.lidr                 -- OK
    SeqDecProbMonadic.lidr         -- OK, but with _many_ metas
    SeqDecProbMonadicExample2.lidr -- OK, but four metas left (argmax)
    SoProperties.lidr              -- OK
    SubType.lidr                   -- OK

2015-02-13: Patrik:

  Added EmbProj which could be more handy for some finite sets (see
  comment in Finite.lidr).

2015-02-12: Patrik: Overview of the files and their imports
  TODO: refactor the imports a bit more

  (While I was off-line a few other commits had solved most of the
  same issues as I did. But some new files were also added and this is
  now the new inventory.)

  No imports:
    Basics.lidr                    -- OK
    Prop.lidr                      -- OK
    Unique.lidr                    -- OK
    Decidable.lidr                 -- OK

  No local imports:
    Finite.lidr                    -- OK
    FinOperations.lidr             -- OK
    IsomorphismOperations.lidr     -- OK

  Almost no local imports:
    FinProperties.lidr             -- OK
    NatProperties.lidr             -- OK
    VectOperations.lidr            -- OK
    VectProperties.lidr            -- OK, but 1 unsolved meta

  Module name same as Finite.lidr: TODO
    finite.lidr                    -- OK, but finiteDecLemma complains about possible partiality

  Intermediate modules (more local dependencies):
    BoundedNat.lidr                -- OK, but 3 unsolved metas (2 SigmaProperties, 1 BoundedNat)
      import Basics, NatProperties, SigmaProperties, FinProperties, Finite

    FiniteOperations.lidr          -- OK
      import Finite, FinOperations, IsomorphismOperations
    FiniteProperties.lidr          -- OK, but 1 unsolved meta (from VectProperties)
      import Finite, FinOperations, IsomorphismOperations,
                     FinProperties,
             FiniteOperations,
             Prop, Decidable,
             VectProperties

    SigmaOperations.lidr           -- OK
      import Finite, Decidable, Unique, FiniteOperations, VectOperations

    SigmaProperties.lidr           -- OK, but 2 unsolved metas
      import SigmaOperations,
             Finite, Decidable, Unique, FiniteOperations, VectOperations

  Goals:
    tagging.lidr                   -- can't unify something with getW
    stochastic.lidr                -- OK, but 4 unsolved metas
    monadic.lidr                   -- OK, with _many_ unsolved metas

  Code from the Idris tutorial section of the paper:
    funprogintro.lidr              -- OK, but 3 unsolved metas

2015-02-12: Patrik: trying out the files

VectProperties.lidr  -- OK!
Basics.lidr          -- OK!
Decidable.lidr       -- OK!
FinProperties.lidr   -- OK!
finite.lidr          -- OK!
funprogintro.lidr    -- OK, with 3 unsolved metas

monadic.lidr         -- can't find Prop
NatProperties.lidr   -- can't find Prop
BoundedNat.lidr      -- can't find Prop
Finite.lidr          -- can't find Proposition
SigmaProperties.lidr -- can't find Unique
tagging.lidr         -- can't unify womething with getW

Checking recent commits: it looks like what was in Proposition should
now be (renamed and in) Unique. => SigmaProperties fixed.
And it looks like Prop is just Prop = Type.
This solves five out of six problems:
monadic.lidr         -- OK, with _many_ unsolved metas
NatProperties.lidr   -- OK
BoundedNat.lidr      -- OK (with 2 unsolved metas from Finite)
Finite.lidr          -- OK, with 2 unsolved metas
SigmaProperties.lidr -- OK

Left is:
tagging.lidr         -- can't unify womething with getW
